{
  "profile": {
    "name": "ElAmir",
    "title": "Software Engineer · NLP Researcher · Instructional Designer",
    "tagline": "Building agentic systems and applying NLP to mental health. 10+ years turning complex ideas into software, research, and courses that make a real difference.",
    "email": "elamirmansour@outlook.com",
    "github": "https://github.com",
    "linkedin": "https://www.linkedin.com/in/elamir-mansour/",
    "medium": "https://medium.com/@elamir",
    "udemy": "https://www.udemy.com/user/elamir-mahmoud-mansour/",
    "youtube": "https://www.youtube.com/@ElAmir",
    "about": "A software engineer and NLP researcher with over a decade of experience building production systems across iOS, full-stack web, and machine learning. Shaped by years of military service that instilled discipline, leadership, and a mission-first mindset. Currently focused on applying transformer models to detect early signs of depression from language — research that sits at the intersection of AI and mental health.",
    "resumeUrl": "#"
  },
  "planets": [
    {
      "id": "ios",
      "name": "iOS Development",
      "color": "#007AFF",
      "neonClass": "neon-blue",
      "icon": "smartphone",
      "orbitRadius": 4,
      "orbitSpeed": 0.3,
      "size": 0.5,
      "eccentricity": 0.15,
      "axialTilt": 12,
      "description": "Native iOS applications built with Swift and SwiftUI. Clean architecture, smooth animations, and pixel-perfect interfaces.",
      "skills": ["Swift", "SwiftUI", "UIKit", "CoreData", "Combine"],
      "projects": [
        {
          "id": "ios-1",
          "title": "Fitness Tracker Pro",
          "description": "A health and fitness app with real-time workout tracking, custom routines, and HealthKit integration.",
          "tags": ["Swift", "SwiftUI", "HealthKit"],
          "link": "#",
          "architecture": "graph TD\nA[SwiftUI Views] --> B[ViewModel]\nB --> C[HealthKit API]\nB --> D[CoreData]\nC --> E[Health Store]\nD --> F[Local Cache]",
          "codeSnippets": [
            {
              "nodeId": "B",
              "language": "swift",
              "filename": "WorkoutViewModel.swift",
              "code": "class WorkoutViewModel: ObservableObject {\n    @Published var heartRate: Double = 0\n    @Published var calories: Double = 0\n    private let healthStore = HKHealthStore()\n\n    func startTracking() {\n        let heartRateType = HKQuantityType\n            .quantityType(forIdentifier: .heartRate)!\n        let query = HKAnchoredObjectQuery(\n            type: heartRateType,\n            predicate: nil,\n            anchor: nil,\n            limit: HKObjectQueryNoLimit\n        ) { [weak self] _, samples, _, _, _ in\n            guard let sample = samples?.last\n                as? HKQuantitySample else { return }\n            DispatchQueue.main.async {\n                self?.heartRate = sample.quantity\n                    .doubleValue(for: .count().unitDivided(by: .minute()))\n            }\n        }\n        healthStore.execute(query)\n    }\n}"
            },
            {
              "nodeId": "D",
              "language": "swift",
              "filename": "PersistenceController.swift",
              "code": "struct PersistenceController {\n    static let shared = PersistenceController()\n    let container: NSPersistentContainer\n\n    init() {\n        container = NSPersistentContainer(name: \"FitnessModel\")\n        container.loadPersistentStores { _, error in\n            if let error = error {\n                fatalError(\"CoreData load failed: \\(error)\")\n            }\n        }\n        container.viewContext.automaticallyMergesChangesFromParent = true\n    }\n\n    func saveWorkout(_ workout: WorkoutData) {\n        let context = container.viewContext\n        let entity = WorkoutEntity(context: context)\n        entity.id = workout.id\n        entity.duration = workout.duration\n        entity.calories = workout.calories\n        try? context.save()\n    }\n}"
            }
          ],
          "technicalChallenges": [
            {
              "question": "Why SwiftUI over UIKit?",
              "decision": "SwiftUI with UIKit bridges for complex views",
              "reasoning": "SwiftUI provides declarative UI composition that speeds up iteration. UIKit bridges were used for the custom workout animation layer where SwiftUI's Canvas API lacked fine-grained control over frame timing."
            },
            {
              "question": "How was HealthKit data synchronized?",
              "decision": "Background fetch with CoreData buffer",
              "reasoning": "HealthKit queries are expensive. A CoreData intermediate cache reduces HealthKit calls to scheduled background fetches, keeping the UI responsive while maintaining data freshness within 15-minute intervals."
            }
          ]
        },
        {
          "id": "ios-2",
          "title": "Smart Notes",
          "description": "An AI-powered note-taking app with natural language search and automatic categorization.",
          "tags": ["Swift", "CoreML", "CloudKit"],
          "link": "#"
        }
      ]
    },
    {
      "id": "fullstack",
      "name": "Full-Stack Engineering",
      "color": "#10B981",
      "neonClass": "neon-green",
      "icon": "code-2",
      "orbitRadius": 6,
      "orbitSpeed": 0.2,
      "size": 0.6,
      "eccentricity": 0.25,
      "axialTilt": 8,
      "description": "End-to-end web applications. From databases to deployment, every layer built with purpose.",
      "skills": ["React", "TypeScript", "Go", "Python", "PostgreSQL", "Docker"],
      "projects": [
        {
          "id": "fs-1",
          "title": "E-Commerce Platform",
          "description": "A scalable marketplace with real-time inventory, payment processing, and analytics dashboard.",
          "tags": ["React", "Go", "PostgreSQL"],
          "link": "#",
          "architecture": "graph TD\nA[React Frontend] -->|REST API| B[Go Backend]\nB --> C[PostgreSQL]\nB --> D[Redis Cache]\nA --> E[Stripe SDK]\nB -->|Webhooks| E[Stripe]",
          "codeSnippets": [
            {
              "nodeId": "B",
              "language": "go",
              "filename": "order_handler.go",
              "code": "func (h *OrderHandler) ProcessCheckout(w http.ResponseWriter, r *http.Request) {\n    var req CheckoutRequest\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n        http.Error(w, \"invalid request\", http.StatusBadRequest)\n        return\n    }\n\n    // Concurrent inventory check using goroutines\n    errCh := make(chan error, len(req.Items))\n    for _, item := range req.Items {\n        go func(i OrderItem) {\n            errCh <- h.inventory.Reserve(r.Context(), i.ProductID, i.Qty)\n        }(item)\n    }\n\n    for range req.Items {\n        if err := <-errCh; err != nil {\n            h.inventory.RollbackAll(r.Context(), req.Items)\n            http.Error(w, err.Error(), http.StatusConflict)\n            return\n        }\n    }\n\n    order, err := h.orders.Create(r.Context(), req)\n    if err != nil {\n        http.Error(w, \"order failed\", http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(order)\n}"
            },
            {
              "nodeId": "C",
              "language": "go",
              "filename": "inventory_repo.go",
              "code": "func (r *InventoryRepo) Reserve(ctx context.Context, productID string, qty int) error {\n    tx, err := r.db.BeginTx(ctx, nil)\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    // Advisory lock prevents deadlocks during flash sales\n    _, err = tx.ExecContext(ctx,\n        \"SELECT pg_advisory_xact_lock(hashtext($1))\", productID)\n    if err != nil {\n        return err\n    }\n\n    var stock int\n    err = tx.QueryRowContext(ctx,\n        \"SELECT stock FROM products WHERE id = $1\", productID,\n    ).Scan(&stock)\n    if err != nil {\n        return err\n    }\n    if stock < qty {\n        return ErrInsufficientStock\n    }\n\n    _, err = tx.ExecContext(ctx,\n        \"UPDATE products SET stock = stock - $1 WHERE id = $2\",\n        qty, productID)\n    if err != nil {\n        return err\n    }\n    return tx.Commit()\n}"
            }
          ],
          "technicalChallenges": [
            {
              "question": "Why Go instead of Node.js for the backend?",
              "decision": "Go with goroutines for concurrent order processing",
              "reasoning": "The marketplace required handling 500+ concurrent checkout sessions. Go's goroutine model provided predictable memory usage under load, unlike Node.js's event loop which showed GC pauses at high concurrency during load testing."
            },
            {
              "question": "How was inventory consistency maintained?",
              "decision": "PostgreSQL advisory locks with optimistic concurrency",
              "reasoning": "Traditional row-level locks caused deadlocks during flash sales. Advisory locks on product IDs combined with version-based optimistic concurrency eliminated deadlocks while maintaining strong consistency."
            }
          ]
        },
        {
          "id": "fs-2",
          "title": "DevOps Dashboard",
          "description": "Centralized monitoring tool for CI/CD pipelines, container health, and deployment metrics.",
          "tags": ["TypeScript", "Docker", "Redis"],
          "link": "#",
          "architecture": "graph TD\nA[Dashboard UI] --> B[WebSocket Server]\nB --> C[Docker API]\nB --> D[CI/CD Hooks]\nC --> E[Container Metrics]\nD --> F[Build Logs]",
          "technicalChallenges": [
            {
              "question": "Real-time updates: WebSocket vs SSE?",
              "decision": "WebSocket with automatic reconnection",
              "reasoning": "Server-Sent Events would have simplified the server, but the dashboard requires bidirectional communication for triggering deployments and sending commands to containers. WebSocket with exponential backoff reconnection provided the reliability needed."
            }
          ]
        }
      ]
    },
    {
      "id": "elearning",
      "name": "E-Learning & Content",
      "color": "#F59E0B",
      "neonClass": "neon-purple",
      "icon": "graduation-cap",
      "orbitRadius": 8,
      "orbitSpeed": 0.15,
      "size": 0.45,
      "eccentricity": 0.1,
      "axialTilt": 5,
      "description": "Educational platforms and content systems that make complex topics accessible and engaging. Over a decade of teaching experience through 'Learn With ElAmir.'",
      "skills": ["LMS Design", "Video Production", "Curriculum Design", "Technical Writing"],
      "impactMetrics": [
        { "label": "YouTube Reach", "value": "15K+", "sublabel": "Subscribers", "icon": "youtube" },
        { "label": "Udemy Students", "value": "3,200+", "sublabel": "Enrolled", "icon": "globe" },
        { "label": "Courses Published", "value": "12", "sublabel": "Active", "icon": "graduation" },
        { "label": "Completion Rate", "value": "78%", "sublabel": "Above Average", "icon": "trending" }
      ],
      "learningPaths": [
        {
          "level": "Beginner",
          "title": "Foundations of Software Engineering",
          "topics": ["Programming Fundamentals", "Data Structures", "Version Control (Git)", "Basic Web Development"]
        },
        {
          "level": "Intermediate",
          "title": "Building Real Applications",
          "topics": ["API Design", "Database Modeling", "Authentication Patterns", "Testing Strategies"]
        },
        {
          "level": "Advanced",
          "title": "Architecture and Scale",
          "topics": ["System Design", "Microservices", "CI/CD Pipelines", "Performance Optimization"]
        }
      ],
      "projects": [
        {
          "id": "el-1",
          "title": "Code Academy Platform",
          "description": "Interactive coding platform with live code execution, progress tracking, and peer review.",
          "tags": ["React", "WebSockets", "Docker"],
          "link": "#"
        },
        {
          "id": "el-2",
          "title": "Tech Tutorial Series",
          "description": "A library of deep-dive technical tutorials covering system design and architecture patterns.",
          "tags": ["Content", "Video", "Writing"],
          "link": "#"
        }
      ]
    },
    {
      "id": "nlp",
      "name": "NLP Research",
      "color": "#8B5CF6",
      "neonClass": "neon-orange",
      "icon": "brain",
      "orbitRadius": 10,
      "orbitSpeed": 0.1,
      "size": 0.55,
      "eccentricity": 0.3,
      "axialTilt": 20,
      "description": "Natural Language Processing research focused on mental health applications. Using transformer models and linguistic analysis to detect early signs of depression from text data.",
      "skills": ["Python", "PyTorch", "Transformers", "spaCy", "NLTK"],
      "researchAbstract": "This research investigates the application of transformer-based language models for early detection of depressive symptoms in unstructured text. By fine-tuning BERT and RoBERTa on curated mental health corpora, the study evaluates how attention mechanisms can capture subtle linguistic markers of depression, including reduced lexical diversity, increased first-person pronoun usage, and persistent negative sentiment patterns.\n\nThe methodology combines domain-adaptive pre-training with multi-task learning to improve generalization across diverse text sources. Preliminary results show that attention-based models outperform traditional feature-engineering approaches by 12-18% in F1 score on held-out clinical validation sets.",
      "researchMilestones": [
        {
          "id": "m1",
          "title": "Literature Review",
          "date": "Sep 2023",
          "status": "completed",
          "description": "Surveyed 80+ papers on NLP-based mental health screening, focusing on transformer architectures for depression detection from social media and clinical text."
        },
        {
          "id": "m2",
          "title": "Dataset Curation",
          "date": "Jan 2024",
          "status": "completed",
          "description": "Collected and preprocessed text corpora from publicly available mental health forums. Applied IRB-compliant anonymization and balanced class distribution."
        },
        {
          "id": "m3",
          "title": "Baseline Models",
          "date": "May 2024",
          "status": "completed",
          "description": "Trained TF-IDF + SVM and LSTM baselines to establish benchmark F1 scores. Results confirmed the need for attention-based architectures."
        },
        {
          "id": "m4",
          "title": "Transformer Fine-Tuning",
          "date": "Oct 2024",
          "status": "in-progress",
          "description": "Fine-tuning BERT and RoBERTa on the curated dataset. Experimenting with domain-adaptive pre-training and multi-task learning objectives."
        },
        {
          "id": "m5",
          "title": "Evaluation & Thesis Writing",
          "date": "Mar 2025",
          "status": "upcoming",
          "description": "Final model evaluation with cross-validation, ablation studies, and comparison against clinical baselines. Drafting the thesis document."
        }
      ],
      "projects": [
        {
          "id": "nlp-1",
          "title": "Sentiment Analysis Engine",
          "description": "Real-time sentiment classifier for social media streams with multilingual support.",
          "tags": ["Python", "Transformers", "FastAPI"],
          "link": "#",
          "architecture": "graph TD\nA[Text Input] --> B[Tokenizer]\nB --> C[BERT Encoder]\nC --> D[Attention Layers]\nD --> E[Classification Head]\nE --> F[Sentiment Score]",
          "codeSnippets": [
            {
              "nodeId": "C",
              "language": "python",
              "filename": "encoder.py",
              "code": "import torch\nfrom transformers import RobertaModel, RobertaTokenizer\n\nclass SentimentEncoder:\n    def __init__(self, model_name=\"roberta-base\"):\n        self.tokenizer = RobertaTokenizer.from_pretrained(model_name)\n        self.model = RobertaModel.from_pretrained(model_name)\n        self.model.eval()\n\n    def encode(self, text: str) -> torch.Tensor:\n        inputs = self.tokenizer(\n            text,\n            return_tensors=\"pt\",\n            truncation=True,\n            max_length=512,\n            padding=\"max_length\"\n        )\n        with torch.no_grad():\n            outputs = self.model(**inputs)\n        # Use [CLS] token embedding\n        return outputs.last_hidden_state[:, 0, :]"
            },
            {
              "nodeId": "E",
              "language": "python",
              "filename": "classifier.py",
              "code": "import torch.nn as nn\n\nclass SentimentClassifier(nn.Module):\n    def __init__(self, hidden_size=768, num_labels=3):\n        super().__init__()\n        self.dropout = nn.Dropout(0.1)\n        self.classifier = nn.Sequential(\n            nn.Linear(hidden_size, 256),\n            nn.ReLU(),\n            nn.Dropout(0.1),\n            nn.Linear(256, num_labels)\n        )\n\n    def forward(self, cls_embedding):\n        x = self.dropout(cls_embedding)\n        logits = self.classifier(x)\n        return logits"
            }
          ],
          "technicalChallenges": [
            {
              "question": "BERT vs RoBERTa for sentiment classification?",
              "decision": "RoBERTa with domain-adaptive pre-training",
              "reasoning": "RoBERTa's dynamic masking and larger batch training showed 3% higher F1 on our mental health text corpus. Domain-adaptive pre-training on unlabeled forum data before fine-tuning further improved recall for subtle negative sentiment by 8%."
            },
            {
              "question": "How were attention weights validated?",
              "decision": "Comparison with human annotator agreement scores",
              "reasoning": "Attention weights were compared against expert annotations of depression markers. Cohen's kappa between model attention and human annotations reached 0.72, confirming the model attends to clinically relevant linguistic features."
            }
          ]
        },
        {
          "id": "nlp-2",
          "title": "Document Summarizer",
          "description": "Abstractive summarization tool for long-form documents using fine-tuned language models.",
          "tags": ["PyTorch", "Hugging Face", "React"],
          "link": "#"
        }
      ]
    },
    {
      "id": "scrum",
      "name": "Scrum & PM",
      "color": "#64748B",
      "neonClass": "neon-cyan",
      "icon": "kanban",
      "orbitRadius": 12,
      "orbitSpeed": 0.08,
      "size": 0.4,
      "eccentricity": 0.05,
      "axialTilt": 3,
      "description": "Agile project management and team leadership. Shipping products on time without burning out the team.",
      "skills": ["Scrum", "Kanban", "Jira", "Confluence", "Stakeholder Management"],
      "projects": [
        {
          "id": "pm-1",
          "title": "Agile Transformation",
          "description": "Led a 40-person engineering org through a waterfall-to-agile transition over 6 months.",
          "tags": ["Scrum", "Leadership", "Process"],
          "link": "#",
          "technicalChallenges": [
            {
              "question": "How was resistance to agile managed?",
              "decision": "Incremental adoption with pilot teams",
              "reasoning": "Rather than a full organizational switch, two pilot teams adopted Scrum for one quarter. Their 40% improvement in delivery predictability created internal demand, making the broader rollout collaborative rather than top-down."
            }
          ]
        },
        {
          "id": "pm-2",
          "title": "Product Roadmap Tool",
          "description": "Internal tool for visual roadmap planning with dependency tracking and capacity forecasting.",
          "tags": ["React", "D3.js", "PostgreSQL"],
          "link": "#",
          "architecture": "graph TD\nA[Roadmap UI] --> B[D3.js Renderer]\nA --> C[API Layer]\nC --> D[PostgreSQL]\nC --> E[Auth Service]\nD --> F[Dependency Graph]"
        }
      ]
    }
  ]
}
